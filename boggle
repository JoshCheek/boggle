#!/usr/bin/env ruby
require 'set'
require 'io/console'

require_relative 'boggle'

board = build_board
chars_to_locations = chars_to_locations(board)

word       = []
words      = []
start      = Time.now
speed      = 1
over       = false
red        = 91
orange     = 93
green      = 32
prev_print = {}

# hide / show cursor
print "\e[?25l"
at_exit { print "\e[?25h" }


# clear the screen
print "\e[H\e[2J"


# read chars instead of lines
$stdin.raw!
at_exit { $stdin.cooked! }


until over
  to_print = ""

  # read input
  (readable, *), (writable, *) = IO.select [$stdin], [$stdout]
  if readable
    readable.readpartial(100).chars.each do |char|
      # Quit on C-c and C-d
      if interrupt?(char) || eof?(char)
        over = true
      # Return submits theword
      elsif char == "\r" || char == "\n"
        matches = matches(word, chars_to_locations)
        words << word if matches.any? && !words.include?(word)
        word = []
      # b/c "Qu" is grouped as a single char, check for that case
      elsif (char == "u" || char == "U") && word.last == "Q"
        word.last << "u"
      # delete
      elsif char.ord == 0x7F
        word.last == 'Qu' ?  word[-1] = 'Q' : word.pop
      # okay, it's a normal character submission
      else
        word << char.upcase
      end
    end
  end

  # quit if we're out of time
  seconds      = Time.now - start
  time_allowed = 60 * 3
  time_passed  = (speed * seconds).to_i
  time_left    = time_allowed - time_passed
  over         = true if time_left < 0 # allow 1s grace :)
  time_left    = 0    if time_left < 0 # but report it as still being at zero

  # skip the rest of this if nothing has changed
  next_print = {
    word:      word.dup,
    words:     words.dup,
    time_left: time_left,
  }
  if prev_print == next_print
    sleep 0.1
    next
  else
    prev_print = next_print
  end

  # find matches
  matches = matches(word, chars_to_locations)

  # clear screen
  to_print << "\e[H\e[2J"

  # print the time
  colour = time_left <= 10 ? red : time_left <= 30 ? orange : green
  to_print << sprintf("\e[1;14HTime:  \e[#{colour}m%d\e[0m   ", time_left)

  # print the number of words found
  to_print << "\e[2;14HWords: #{words.length}"

  # print the score
  score = words.reduce(0) { |score, word| score + word_score(word) }
  to_print << sprintf("\e[3;14HScore: %d", score)

  # print the board
  path_locations = Set.new matches.flatten(1)
  head_locations = Set.new matches.map(&:last)

  to_print << show_board(board, path_locations, head_locations)

  # print the word
  if matches.any? || word.empty?
    to_print << "\e[92m" # bright green
  else
    to_print << "\e[91m" # bright red
  end
  to_print << "\r\n> " << word.join.downcase << "\e[0m\r\n" << "\r\n"

  # print the words
  cols, rows = $stdin.winsize
  cols -= 7 # for the stuff previously printed
  xoffset = 1
  words.each_slice(cols) do |word_set|
    max_score = 0
    word_set.each.with_index(8) do |word, yoffset|
      score = word_score(word)
      max_score = score if max_score < score
      to_print << ("\e[#{yoffset};#{xoffset}H%2d %s\r\n" % [
        score, word.join.downcase
      ])
    end
    to_print.chomp! "\r\n"
    xoffset += max_score.to_s.length
    xoffset += word_set.map(&:length).max + 3 # 3 for the gap between words
  end

  print to_print
end

print "\r\n\n\e[41;97m GAME OVER!! \e[0m\e[J\r\n"
